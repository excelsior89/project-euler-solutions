// Copyright 2020 Paul Robertson
//
// PeProblem2.cpp
//
// "Even Fibonacci numbers"

#include "PeProblem2.h"

using namespace std;

namespace pe {

// The brute force solution: find the sum of even Fibonacci numbers
// up to limit
static PeUint Method1(PeUint limit)
{
	PeUint cumulative_sum = 0;

	PeUint t0 = 0, t1 = 1; // Base case terms

	PeUint tn = 1;

	// Continue until limit reached
	while (tn <= limit) {
		// Add term if even
		if (!(tn & 1)) cumulative_sum += tn;

		// Calculate next term
		tn = t0 + t1;
		t0 = t1;
		t1 = tn;
	}

	return cumulative_sum;
}

// An improvement on Method1 which only calculates the even terms
static PeUint Method2(PeUint limit)
{
	PeUint cumulative_sum = 0;

	PeUint t0 = 0, t1 = 2; // Base case terms

	PeUint tn = 2;

	// Continue until limit reached
	while (tn <= limit) {
		// Every term is even so no need to check
		cumulative_sum += tn;
		// Calculate next term
		tn = t0 + 4*t1;
		t0 = t1;
		t1 = tn;
	}

	return cumulative_sum;
}

// A "direct" solution which uses some tricksy maths...
static PeUint Method3(PeUint limit)
{
	PeUint n = (PeUint)floor((log((double)limit) + log(5.0) / 2.0) / log(math::kPhi));

	return (math::FibonacciDirect(n + 3) + math::FibonacciDirect(n) - 2) / 4;
}


ostream &PeProblem2::DisplayProblem(ostream &os)
{
	os << formatting::ProblemHeader(kProblemNumber) << endl << endl <<
		"Each new term in the Fibonacci sequence is generated by adding the previous" << endl <<
		"two terms. By starting with 1 and 2, the first 10 terms will be:" << endl <<
		"\t1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ..." << endl <<
		"By considering the terms in the Fibonacci sequence whose values" << endl <<
		"do not exceed four million, find the sum of the even-valued terms." << endl << endl;

	return os;
}


ostream &PeProblem2::DisplaySolution(ostream &os)
{
	const PeUint kLimit = 4000000;
	os << formatting::SolutionHeader(kProblemNumber) << endl << endl <<
		"Answer: " << Method3(kLimit) << endl << endl <<
		formatting::MethodHeader(1) << endl << endl <<
		"Simple brute-force summation can easily compute the answer:" << endl <<
		"Calculate the Fibonacci sequence (T_n = T_n-1 + T_n-2) iteratively until" << endl <<
		"the limit and accumulate the sum of even terms (i.e. mod(term,2)==0)." << endl << endl <<
		"Method 1 solution: " << Method1(kLimit) << endl << endl <<

		formatting::MethodHeader(2) << endl << endl <<
		"A slight improvement to solution 1:" << endl <<
		"For the Fibonacci sequence, it also holds that T_n = 4*T_n-3 + T_n-6." << endl <<
		"Seeing that the even terms of the Fibonacci sequence are every third term," << endl <<
		"we can leverage the above to only calculate the even terms." << endl << endl <<
		"Method 2 solution: " << Method2(kLimit) << endl << endl <<

		formatting::MethodHeader(3) << endl << endl <<
		"A \"direct\" calculation:" << endl <<
		"Based on the relation T_n+3 = 4*T_n + T_n-3, we rearrange:" << endl <<
		"\t4*T_n = T_n+3 - T_n-3" << endl <<
		"We can write each iteration of this down to T_1 (only using even iterations):" << endl <<
		"\t4*T_n   =  T_n+3 -  T_n-3" << endl <<
		"\t4*T_n-3 =  T_n   -  T_n-6" << endl <<
		"\t4*T_n-6 =  T_n-3 -  T_n-9" << endl <<
		"\t..." << endl <<
		"\t4*T_10  =  T_13  -  T_7" << endl <<
		"\t4*T_7   =  T_10  -  T_4" << endl <<
		"\t4*T_4   =  T_7   -  T_1" << endl <<
		"Adding all the above equations together, we see that:" << endl <<
		"\t4*sum(T_4...T_n) = T_n+3 + T_n - T_4 - T_1" << endl <<
		"\tsum(T_4...T_n) = (T_n+3 + T_n - T_4 - T_1)/4" << endl <<
		"\tT_1 + sum(T_4...T_n) = (T_n+3 + T_n - T_4 - T_1)/4 + T_1" << endl <<
		"\tsum(T_1...T_n) = (T_n+3 + T_n - T_4 - T_1)/4 + T_1" << endl <<
		"Taking T_1 = 0, T_4 = 2 (or alternatively, T_1 = 2, T_4 = 8) gives:" << endl <<
		"\tsum(T_1...T_n) = (T_n+3 + T_n - 2)/4" << endl << endl <<
		"The \"direct\" part of this solution also rests on the direct formula for" << endl <<
		"the Nth Fibonacci number:" << endl <<
		"\tF(n) = round(Phi^n/sqrt(5)), where Phi = (1 + sqrt(5))/2" << endl <<
		"Note this formula will become inaccurate for large values of n due to" << endl <<
		"floating point limitations." << endl <<
		"The formula for the sum of even Fibonacci numbers is thus:" << endl <<
		"\tsum(T_1...T_n) = (round(Phi^(n+3)/sqrt(5)) + round(Phi^n/sqrt(5))- 2)/4" << endl << endl <<
		"A final part of this solution requires us to use the same formula for the" << endl <<
		"Nth Fibonacci number to determine N in relation to the limit." << endl <<
		"Taking the logs and rearranging gives:" << endl <<
		"\tN = (log(limit) + log(5)/2) / log(Phi)" << endl <<
		"If limit is not a Fibonacci number then N is fractional." << endl <<
		"Rounding down gives N of the nearest Fibonacci number below the limit." << endl <<
		"\tN = floor((log(limit) + log(5)/2) / log(Phi))" << endl <<
		"We therefore calculate the required N, then calculate T_N and T_N+3" << endl <<
		"and finally calculate the sum." << endl << endl <<
		"Method 3 solution: " << Method3(kLimit) << endl << endl;

	return os;
}

// Solution profiling

#define PROFILE_RETURN_TYPE_ PeUint
#define PROFILE_INPUT_TYPES_ PeUint
#define PROFILE_ARGS_ 10000000

PROFILE_SOLUTIONS(PeProblem2, Method1, Method2)

#undef PROFILE_RETURN_TYPE_
#undef PROFILE_INPUT_TYPES_
#undef PROFILE_ARGS_

}; // namespace pe